<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bayesian SIR Workflow</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .code-block {
            background-color: #f3f4f6;
            border-radius: 0.5rem;
            padding: 1rem;
            overflow-x: auto;
        }
        .figure-placeholder {
            width: 100%;
            height: 400px;
            background-color: #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.5rem;
            margin-top: 1rem;
            font-style: italic;
            color: #6b7280;
            text-align: center;
        }
        pre {
            margin: 0;
        }
    </style>
</head>
<body class="bg-white text-gray-800 antialiased leading-relaxed">

    <div class="container mx-auto max-w-4xl px-4 py-8">
        <header class="text-center mb-12">
            <h1 class="text-4xl font-bold tracking-tight text-gray-900 sm:text-5xl">SIR Modelling with a Bayesian Workflow</h1>
            <p class="mt-4 text-xl text-gray-600">
                Jake Cordery - August 2025 
            </p>
        </header>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-gray-900 mb-4">0. Introduction</h2>
            <p class="text-gray-700 mb-6">
                This project extends the use of deterministic SIR ODEs by using Bayesian machine learning.
                This is done by using Bayes' theorem in order to refine a prior distribution of the possible 
                parameter values of the system of ODEs, which allows more accurate predictions 
                as well as the incorporation of uncertainty when forecasting the spread of disease.
                <br><br>
                Julia is an excelllent programming language to do this in, due to its high-level and 
                intuitive syntax, which allows quick prototyping - similar to Python. However, Julia 
                also achieves performance which is comparable to C - where Python falls short.
                <br><br>
                Julia was also designed with mathematical and numerical programming in mind, hence the 
                large array of packages with optimised algorithms for this style of project. The star of this
                project is the package Turing.jl - a statistical programming language which allows streamlined
                prototyping and ultra-performant Bayesian inference.
                <br><br>
                The structure of this project follows that of a Bayesian Workflow: 
                    1. Model building
                    2. Inference 
                    3. Model checking (and or improvement)
            </p>
        </section>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-gray-900 mb-4">1. Model Building & Synthetic Data Generation</h2>
            <p class="text-gray-700 mb-6">
                The first step is to define the system of ODEs which govern the disease mechanics, the SIR model is 
                perfect for simple mathematical modelling of a disease. The SIR model splits a population into three 
                compartments: Susceptible, Infected and Recovered. The mathematics is:

                As can be seen, the rate of change in one compartment, depends on the infection rate β or the recovery 
                rate γ, and the interacting populations. The Julia code below defines the system of equations:
            </p>
            <div class="code-block">
                <pre><code>using Turing, DifferentialEquations, Distributions

using Random
Random.seed!(42)

using StatsPlots, MCMCChains, Plots

# -----------
# Model building
# -----------
function sir(du, u, p, t)
    S, I, R = u
    β, γ = p
    N = S + I + R
    du[1] = -β * S * I / N
    du[2] = β * S * I / N - γ * I
    du[3] = γ * I
end</code></pre>
            </div>
            
            <p class="text-gray-700 mt-6 mb-6">
                Within this system, β is the infection rate and γ is the recovery rate - these allow a variety of diseases to be modelled.
                In this case, I chose the recovery time to be roughly 10 days, which gives γ=0.1.
                β=0.25 says that roughly a quarter of interactions will result in the disease being transmitted.
                <br><br>
                R_0 is the basic reproductive number, which is the expected number of cases directly generated 
                by one case in a population where all individuals are susceptible to infection. R_0 is given by
                R_0=β/γ, hence, in this case, R_0=2.5, which for context gives it a similar infection profile to the common cold.
                <br><br>
                Using these values, the model with known parameters is used to calculate the solution to the system of ODEs.
                Adding Gaussian noise mimics the reporting biases, miscounting and other inconsistencies which is seen in 
                real-world data.
                <br><br>
                The code below gives the initial conditions:
                    - N (population) = 10,000
                    - I_0 (Inital number of individuals with the disease) = 75
                    - R_0 (Initial number of individuals who are immune to the disease) = 0
            </p>
            <div class="code-block">
                <pre><code># Synthetic data generation
N = 1e4
β_true = 0.25 # per day
γ_true = 0.10 # per day (≈ 10-day infectious period)
p = [β_true, γ_true]

I0 = 75.0
S0 = N - I0
R0 = 0.0
u0 = [S0, I0, R0]

tspan = (0.0, 100.0)

# Generate synthetic data
prob = ODEProblem(sir, u0, tspan, p)
sol = solve(prob, Tsit5())
plot(sol, title="Solution to β=$β_true and γ=$γ_true")
savefig("figs/true_sol.png")

sol = solve(prob, Tsit5(), saveat=0.1)
noise = 250 * randn(size(Array(sol)))
odedata = Array(sol) + noise
plot(sol, title="Solution to β=$β_true and γ=$γ_true\nwith Gaussian noise")
scatter!(sol.t, odedata', markersize=1)
savefig("figs/noisy_true_sol.png")</code></pre>
            </div>

            <h3 class="text-2xl font-semibold text-gray-900 mt-8 mb-2">Figure 1: True Solution</h3>
            <p class="text-gray-700 mb-4">
                The solution of the SIR model with β, γ = 0.25, 0.1. The blue trajectory is the Susceptible compartment, 
                the green is the Infected compartment and the orange is the Recovered compartment
            </p>
            <div class="figure-placeholder">
                <img src="scientific-programming-julia/figs/true_sol.png" alt="Plot of the true SIR solution." class="w-full h-full object-cover rounded-lg">
            </div>

            <h3 class="text-2xl font-semibold text-gray-900 mt-8 mb-2">Figure 2: Noisy Data</h3>
            <p class="text-gray-700 mb-4">
                The solution from before, with added Gaussian noise.
            </p>
            <div class="figure-placeholder">
                <img src="scientific-programming-julia/figs/noisy_true_sol.png" alt="Plot of the true SIR solution with noise." class="w-full h-full object-cover rounded-lg">
            </div>
        </section>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-gray-900 mb-4">1.5 Bayesian Model Specification</h2>
            <p class="text-gray-700 mb-6">
                The next step is to build the Bayesian model. This involves two key components: 
                    - specifying our prior beliefs (to inform the parameters)
                    - defining the likelihood that connects our model's predictions to the observed data.
                
                <br><br>
                To begin with, imagine a dataset of recovery times for the disease, this dataset shows a range of values
                from a few days to a month, with the mode being 10 - we may be able to say from this that the recovery time
                is around 10 days, but with a fair bit of uncertainty. Setting the weakly-informed prior as γ ~ Normal(log(0.1), 0.5)
                encompasses recovery times from 1 day to 74 days.
                <br><br>
                Then, for a disease to become an epidemic, R_0 > 0. Our guess of 2 is a good starting point and the prior β ~ Normal(log(2.0), 0.4)
                encompasses any R_0 value from 0.9 to 4.4. Hence β can be calculated via β=R_0 * γ.

                <br><br>
                The code below uses Turing.jl's `@model` macro to define this. 
                @model enables the user to assign probability distributions to variables in the function.
                It also takes data in as input, then calculates the likelihoods, which then connects the 
                parameters to the observations. It also automatically prepares the model for inference in 
                the MCMC algorithm.
            </p>
            <div class="code-block">
                <pre><code>@model function sir_model(data, prob)
    log_γ ~ Normal(log(0.1), 0.5)
    log_R0 ~ Normal(log(2.0), 0.4)
    σ ~ truncated(Cauchy(0, 100), 0, Inf)

    γ = exp(log_γ)
    R0 = exp(log_R0)
    β = R0 * γ

    p = [β, γ]
    prob = remake(prob, p=p)
    predicted = solve(prob, Tsit5(), saveat=0.1)
    
    for i in eachindex(predicted)
        data[:, i] ~ MvNormal(predicted[i], σ)
    end
end</code></pre>
            </div>
        </section>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-gray-900 mb-4">Training???@</h2>
            <p class="text-gray-700 mb-6">
                Now the Bayesian model is defined, the sampling algorithm No-U-Turn Sampler (NUTS)
                will draw thousands of samples from the posterior distribution. 
                The posterior distribution represents our updated beliefs about the parameters after we've seen the data.
            </p>
            <div class="code-block">
                <pre><code># -----------
# Inference
# -----------
model = sir_model(odedata, prob)
chain = mapreduce(c -> sample(model, NUTS(.65),1000), chainscat, 1:3)

plot(chain)
savefig("figs/chain.png")

# Posterior analysis
display(summarystats(chain))</code></pre>
            </div>
            <h3 class="text-2xl font-semibold text-gray-900 mt-8 mb-2">Figure 3: Chain Plot</h3>
            <p class="text-gray-700 mb-4">
                This plot shows the trace and density of the posterior samples. The trace plot has no obvious
                trends as it is exploring the parameter space. 
                The density plots show the posterior distribution for each parameter. 
                The mean of the posterior distributions is close to the true parameter values we used to 
                generate the data ($$\beta \approx 0.25, \gamma \approx 0.10$$).
            </p>
            <div class="figure-placeholder">
                <img src="https://github.com/JIC1444/JIC1444.github.io/blob/main/scientific-programming-julia/figs/chain.png" alt="Plot of the MCMC chains, showing trace and density plots for the parameters." class="w-full h-full object-cover rounded-lg">
            </div>
        </section>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-gray-900 mb-4">3. Model Checks</h2>
            <p class="text-gray-700 mb-6">
                The next step in a Bayesian Workflow, is to check if the fitted model can reproduce data 
                which closely resembles the observed 
                data. By taking many samples from the posterior distribution (the `chain`) 
                they can be used
                 to generate new simulated data. We then plot these simulated trajectories 
                on top of the original noisy data.
            </p>
            <div class="code-block">
                <pre><code># -----------
# Use model to generate data
# -----------
log_gammas = chain[:log_γ]
log_R0s = chain[:log_R0]
gammas = exp.(log_gammas)
R0s = exp.(log_R0s)
betas = gammas .* R0s
print(size(betas))

# The number of simulations you want to run
num_simulations = length(betas)
simulated_infected = Vector{Vector{Float64}}(undef, num_simulations)
for i in 1:num_simulations
    β_i = betas[i]
    γ_i = gammas[i]
    
    # Define the ODE problem with these specific parameters
    p_i = [β_i, γ_i]
    prob = ODEProblem(sir, u0, tspan, p_i)

    # Solve the ODE
    sol = solve(prob, Tsit5())
    
    # Store the infected individuals trajectory
    simulated_infected[i] = sol[2, :] 
end

p = plot(title="Posterior-Informed Data", legend=false)
for i in 1:num_simulations
    plot!(p, sol.t, simulated_infected[i], alpha=0.1, color=:blue)
end
display(p)
savefig("figs/generated_sols.png")</code></pre>
            </div>
            <h3 class="text-2xl font-semibold text-gray-900 mt-8 mb-2">Figure 4: Posterior-Informed Data</h3>
            <p class="text-gray-700 mb-4">
                This plot shows a "cloud" of new trajectories generated by our model. 
                If our model is a good fit, the cloud of these trajectories should closely 
                overlap with the original noisy data, demonstrating that our model is capable 
                of generating data that looks like what we observed.
            </p>
            <div class="figure-placeholder">
                <img src="https://placehold.co/600x400?text=Figure+4:+Posterior+Predictive+Checks" alt="Placeholder for a plot showing a cloud of simulated trajectories." class="w-full h-full object-cover rounded-lg">
            </div>
        </section>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-gray-900 mb-4">4. Forecasting</h2>
            <p class="text-gray-700 mb-6">
                Finally, we use the posterior distribution to make predictions about the future. 
                By running the model forward in time with multiple sets of parameters drawn from 
                our posterior, we can quantify the uncertainty in our forecasts. 
            </p>
            <div class="code-block">
                <pre><code># -----------
# Forecasting
# -----------
forecast_length = [5, 15, 30]
forecast_from = [20, 35, 60]

t_end_historical = 100.0
I_0 = 75.0
u0_historical = [N - I0, I0, 0.0]
p_historical = [0.25, 0.1] # Use mean of your posterior or a single good-fit value
prob_historical = ODEProblem(sir_ode!, u0_historical, (0.0, t_end_historical), p_historical)
sol_historical = solve(prob_historical, Tsit5())

# Plot same day on rows, forecast length on the columns
p_grid = []

betas = [0.2 + 0.01 * randn() for _ in 1:1000]
gammas = [0.1 + 0.005 * randn() for _ in 1:1000]

# Loop through each starting day
# Generate a cloud of historical trajectories
historical_trajectories = []
for i in 1:num_forecast_sims
    β = betas[i]
    γ = gammas[i]
    p = [β, γ]
    prob_hist = ODEProblem(sir_ode!, u0_historical, (0.0, t_end_historical), p)
    sol_hist = solve(prob_hist, Tsit5())
    push!(historical_trajectories, sol_hist)
end

# Define the forecast lengths and starting days
forecast_length = [5, 15, 30]
forecast_from = [20, 35, 60]

# Prepare a layout for the 3x3 plot
p_grid = []

num_forecast_sims = 500

for start_day in forecast_from
    for forecast_len in forecast_length
        # Setup forecast from the historical solution
        u0_forecast = sol_historical(start_day)
        tspan_forecast = (start_day, start_day + forecast_len)
        
        # Create a subplot for this specific combination
        p_subplot = plot(title="Day $start_day - $(start_day+forecast_len)", legend=false)
        
        # Add a vertical line to show where the forecast starts
        vline!([start_day], linestyle=:dash, color=:black, label=false)
        
        for i in 1:num_forecast_sims
            β = betas[i]
            γ = gammas[i]
            p = [β, γ]
            
            prob_forecast = ODEProblem(sir, u0_forecast, tspan_forecast, p)
            sol_forecast = solve(prob_forecast, Tsit5())

            # Plot the individual forecast trajectory on the current subplot
            plot!(p_subplot, sol_forecast, vars=(0, 2), alpha=0.1, color=:lightblue1)
        end
        
        # Add the historical curve for context
        plot!(p_subplot, sol_historical, vars=(0, 2), xlims=(0, tspan_forecast[2]), color=:gray, linewidth=2, label=false)
        push!(p_grid, p_subplot)
    end
end

plot(p_grid..., layout=(3, 3), size=(1200, 1200), xlabel="Time (days)", ylabel="Infected Population")
savefig("figs/forecast.png")</code></pre>
            </div>
            <h3 class="text-2xl font-semibold text-gray-900 mt-8 mb-2">Figure 5: Forecast</h3>
            <p class="text-gray-700 mb-4">
                This shows a series of forecasts starting from different time points. Dates which 
                precede a large increases in case numbers are expected to be more uncertain,
                whereas the stable increase/decreases should be relatively accurate. When trying
                to predict further in time, the uncertainty will also grow.
                <br><br>
                This is exactly what is observed in the plot, as the blue trajectories do 
                <br><br>

            </p>
            <div class="figure-placeholder">
                <img src="https://placehold.co/600x400?text=Figure+5:+Forecasting+Results" alt="Placeholder for a grid plot showing multiple forecast simulations." class="w-full h-full object-cover rounded-lg">
            </div>
        </section>

    </div>
</body>
</html>