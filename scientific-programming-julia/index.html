<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bayesian SIR Workflow</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // MathJax configuration to explicitly define delimiters
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .code-block {
            background-color: #f3f4f6;
            border-radius: 0.5rem;
            padding: 1rem;
            overflow-x: auto;
        }
        .figure-container {
            margin-top: 1rem;
            margin-bottom: 2rem;
        }
        .figure-container img {
            width: 100%;
            height: auto; /* Ensures images are not cropped */
            max-height: 400px; /* Optional: Sets a max height for large images */
            object-fit: contain; /* Prevents cropping and shows full image */
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        pre {
            margin: 0;
        }
        .equations {
            display: flex;
            justify-content: center;
            margin-bottom: 1rem;
        }
        .equations-inner {
            text-align: center;
        }
    </style>
</head>
<body class="bg-white text-gray-800 antialiased leading-relaxed">

    <div class="container mx-auto max-w-4xl px-4 py-8">
        <header class="text-center mb-12">
            <h1 class="text-4xl font-bold tracking-tight text-gray-900 sm:text-5xl">SIR Modelling with a Bayesian Workflow</h1>
            <p class="mt-4 text-xl text-gray-600">
                Jake Cordery - August 2025
            </p>
        </header>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-gray-900 mb-4">0. Introduction</h2>
            <p class="text-gray-700 mb-6">
                This project extends the use of deterministic SIR ODEs by using Bayesian machine learning. This is done by using Bayes' theorem in order to refine a prior distribution of the possible parameter values of the system of ODEs, which allows more accurate predictions as well as the incorporation of uncertainty when forecasting the spread of disease.
                <br><br>
                Julia is an excelllent programming language to do this in, due to its high-level and intuitive syntax, which allows quick prototyping - similar to Python. However, Julia also achieves performance which is comparable to C - where Python falls short.
                <br><br>
                Julia was also designed with mathematical and numerical programming in mind, hence the large array of packages with optimised algorithms for this style of project. The star of this project is the package Turing.jl - a statistical programming language which allows streamlined prototyping and ultra-performant Bayesian inference.
                <br><br>
                The structure of this project follows that of a Bayesian Workflow:
                <br>
                1. Model building
                <br>
                2. Inference
                <br>
                3. Model checking (and or improvement)
            </p>
        </section>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-gray-900 mb-4">1. Model Building & Synthetic Data Generation</h2>
            <p class="text-gray-700 mb-6">
                The first step is to define the system of ODEs which govern the disease mechanics, the SIR model is perfect for simple mathematical modelling of a disease. The SIR model splits a population into three compartments: Susceptible ($S$), Infected ($I$) and Recovered ($R$). The mathematical equations are as follows:
            </p>
            <div class="equations">
                <div class="equations-inner">
                    $$
                    \frac{dS}{dt} = -\frac{\beta SI}{N}, \quad
                    \frac{dI}{dt} = \frac{\beta SI}{N} - \gamma I, \quad
                    \frac{dR}{dt} = \gamma I
                    $$
                </div>
            </div>
            <p class="text-gray-700 mb-6">
                As can be seen, the rate of change in one compartment depends on the infection rate $\beta$ or the recovery rate $\gamma$, and the interacting populations. The Julia code below defines the system of equations:
            </p>
            <div class="code-block">
                <pre><code>using Turing, DifferentialEquations, Distributions

using Random
Random.seed!(42)

using StatsPlots, MCMCChains, Plots

# -----------
# Model building
# -----------
function sir(du, u, p, t)
    S, I, R = u
    β, γ = p
    N = S + I + R
    du[1] = -β * S * I / N
    du[2] = β * S * I / N - γ * I
    du[3] = γ * I
end</code></pre>
            </div>

            <p class="text-gray-700 mt-6 mb-6">
                Within this system, $\beta$ is the infection rate and $\gamma$ is the recovery rate - these allow a variety of diseases to be modelled. In this case, I chose the recovery time to be roughly 10 days, which gives $\gamma = 0.1$. $\beta = 0.25$ says that roughly a quarter of interactions will result in the disease being transmitted.
                <br><br>
                $R_0$ is the basic reproductive number, which is the expected number of cases directly generated by one case in a population where all individuals are susceptible to infection. $R_0$ is given by $R_0=\beta/\gamma$, hence, in this case, $R_0 = 2.5$, which for context gives it a similar infection profile to the common cold.
                <br><br>
                Using these values, the model with known parameters is used to calculate the solution to the system of ODEs. Adding Gaussian noise mimics the reporting biases, miscounting and other inconsistencies which is seen in real-world data.
                <br><br>
                The code below gives the initial conditions:
                <br>
                - $N$ (population) = 10,000
                <br>
                - $I_0$ (Inital number of individuals with the disease) = 75
                <br>
                - $R_0$ (Initial number of individuals who are immune to the disease) = 0
            </p>
            <div class="code-block">
                <pre><code># Synthetic data generation
N = 1e4
β_true = 0.25 # per day
γ_true = 0.10 # per day (≈ 10-day infectious period)
p = [β_true, γ_true]

I0 = 75.0
S0 = N - I0
R0 = 0.0
u0 = [S0, I0, R0]

tspan = (0.0, 100.0)

# Generate synthetic data
prob = ODEProblem(sir, u0, tspan, p)
sol = solve(prob, Tsit5())
plot(sol, title="Solution to β=$β_true and γ=$γ_true")
savefig("figs/true_sol.png")

sol = solve(prob, Tsit5(), saveat=0.1)
noise = 250 * randn(size(Array(sol)))
odedata = Array(sol) + noise
plot(sol, title="Solution to β=$β_true and γ=$γ_true\nwith Gaussian noise")
scatter!(sol.t, odedata', markersize=1)
savefig("figs/noisy_true_sol.png")</code></pre>
            </div>

            <h3 class="text-2xl font-semibold text-gray-900 mt-8 mb-2">Figure 1: True Solution</h3>
            <p class="text-gray-700 mb-4">
                The solution of the SIR model with $\beta, \gamma = 0.25, 0.1$. The blue trajectory is the Susceptible compartment, the green is the Infected compartment and the orange is the Recovered compartment.
            </p>
            <div class="figure-container">
                <img src="https://github.com/JIC1444/JIC1444.github.io/raw/a3b7701c1d331c49484e4ca1b202dbe4ae5cfd1e/scientific-programming-julia/figs/true_sol.png" alt="Plot of the true SIR solution.">
            </div>

            <h3 class="text-2xl font-semibold text-gray-900 mt-8 mb-2">Figure 2: Noisy Data</h3>
            <p class="text-gray-700 mb-4">
                The solution from before, with added Gaussian noise.
            </p>
            <div class="figure-container">
                <img src="https://github.com/JIC1444/JIC1444.github.io/raw/a3b7701c1d331c49484e4ca1b202dbe4ae5cfd1e/scientific-programming-julia/figs/noisy_true_sol.png" alt="Plot of the true SIR solution with noise.">
            </div>
        </section>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-gray-900 mb-4">2. Bayesian Model Definition</h2>
            <p class="text-gray-700 mb-6">
                The next step is to build the Bayesian model. This involves two key components:
                <br>
                - specifying our prior beliefs (to inform the parameters)
                <br>
                - defining the likelihood that connects our model's predictions to the observed data.
                <br><br>
                To begin with, imagine a dataset of recovery times for the disease, this dataset shows a range of values from a few days to a month, with the mode being 10 - we may be able to say from this that the recovery time is around 10 days, but with a fair bit of uncertainty. Setting the weakly-informed prior as $\gamma \sim \text{Normal}(\log(0.1), 0.5)$ encompasses recovery times from 1 day to 74 days.
                <br><br>
                Then, for a disease to become an epidemic, $R_0 > 1$. Our guess of 2 is a good starting point and the prior $\beta \sim \text{Normal}(\log(2.0), 0.4)$ encompasses any $R_0$ value from 0.9 to 4.4. Hence $\beta$ can be calculated via $\beta=R_0 \cdot \gamma$.
                <br><br>
                The code below uses Turing.jl's `@model` macro to define this. `@model` enables the user to assign probability distributions to variables in the function. It also takes data in as input, then calculates the likelihoods, which then connects the parameters to the observations. It also automatically prepares the model for inference in the MCMC algorithm.
            </p>
            <div class="code-block">
                <pre><code>@model function sir_model(data, prob)
    log_γ ~ Normal(log(0.1), 0.5)
    log_R0 ~ Normal(log(2.0), 0.4)
    σ ~ truncated(Cauchy(0, 100), 0, Inf)

    γ = exp(log_γ)
    R0 = exp(log_R0)
    β = R0 * γ

    p = [β, γ]
    prob = remake(prob, p=p)
    predicted = solve(prob, Tsit5(), saveat=0.1)
    
    for i in eachindex(predicted)
        data[:, i] ~ MvNormal(predicted[i], σ)
    end
end</code></pre>
            </div>
        </section>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-gray-900 mb-4">3. Sampling</h2>
            <p class="text-gray-700 mb-6">
                Now the Bayesian model is defined, the sampling algorithm No-U-Turn Sampler (NUTS) will draw thousands of samples from the posterior distribution. The posterior distribution represents our updated beliefs about the parameters after we've seen the data.
            </p>
            <div class="code-block">
                <pre><code># -----------
# Inference
# -----------
model = sir_model(odedata, prob)
chain = mapreduce(c -> sample(model, NUTS(.65),1000), chainscat, 1:3)

plot(chain)
savefig("figs/chain.png")

# Posterior analysis
display(summarystats(chain))</code></pre>
            </div>

            <h3 class="text-2xl font-semibold text-gray-900 mt-8 mb-2">Figure 3: Chain Plot</h3>
            <p class="text-gray-700 mb-4">
                This plot shows the trace and density of the posterior samples. The trace plot has no obvious trends as it is exploring the parameter space.
                <br><br>
                The density plots show the posterior distribution for each parameter. The summary of the chain shows that the mean of the posterior distributions is close to the true parameter values used to generate the data:
                $$ \beta \approx 0.25, \gamma \approx 0.10 $$
            </p>
            <div class="figure-container">
                <img src="https://github.com/JIC1444/JIC1444.github.io/raw/bfdd03620461bc068b5063008016c38005339676/scientific-programming-julia/figs/chain.png" alt="Plot of the MCMC chains, showing trace and density plots for the parameters.">
            </div>
            <div class="figure-container">
                <img src="https://github.com/JIC1444/JIC1444.github.io/raw/29c4b6783339d47068efc7cb87a14ddd06046f70/scientific-programming-julia/figs/chain_summary.png" alt="Chain Summary.">
            </div>

        </section>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-gray-900 mb-4">4. Model Checking</h2>
            <p class="text-gray-700 mb-6">
                The next step in a Bayesian Workflow is to check if the fitted model can reproduce data which closely resembles the observed data. By taking many samples from the posterior distribution (1000 in this case) these can be put into the ODE and solved to generate similar data.
            </p>
            <div class="code-block">
                <pre><code># -----------
# Use model to generate data
# -----------
log_gammas = chain[:log_γ]
log_R0s = chain[:log_R0]
gammas = exp.(log_gammas)
R0s = exp.(log_R0s)
betas = gammas .* R0s
                    
num_simulations = length(betas)
simulated_infected = Vector{Vector{Float64}}(undef, num_simulations)
time_points = sol.t
                    
generated_plot = plot(
    xlabel = "Time",
    ylabel = "I(t)",
    title = "Posterior Predictive Checks",
    legend = false,
)
                    
for i in 1:num_simulations
    β_i = betas[i]
    γ_i = gammas[i]
                        
    p_i = [β_i, γ_i]
    prob_i = ODEProblem(sir, u0, tspan, p_i)
                    
    # Solve the ODE and save at the same time points
    sol_i = solve(prob_i, Tsit5(), saveat=time_points)
    plot!(generated_plot, sol_i.t, sol_i[2, :], color=:black, alpha=0.9)
end
                    
savefig(generated_plot, "figs/generated_sols.png")</code></pre>
            </div>
            <h3 class="text-2xl font-semibold text-gray-900 mt-8 mb-2">Figure 4: Posterior-Informed Data</h3>
            <p class="text-gray-700 mb-4">
                This shows that the generated trajectories generated by the posteriors are a good fit, as the cloud of these trajectories closely resembles the original data (without noise).
            </p>
            <div class="figure-container">
                <img src="https://github.com/JIC1444/JIC1444.github.io/raw/e5264ba1e31607807a1de21addf2e7f9874edfd0/scientific-programming-julia/figs/generated_sols.png" alt="A plot showing a cloud of simulated trajectories.">
            </div>

        </section>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-gray-900 mb-4">5. Forecasting</h2>
            <p class="text-gray-700 mb-6">
                Finally, the posterior distribution can be used to make predictions about the future, from day any $n$ to $n+m$ within the epidemic. By running the model forward in time with multiple sets of parameters drawn from the posterior, we can quantify the uncertainty in the forecasts.
            </p>
            <div class="code-block">
                <pre><code># -----------
# Forecasting
# -----------
forecast_length = [5, 15, 30]
forecast_from = [20, 35, 60]

t_end_historical = 100.0
I_0 = 75.0
u0_historical = [N - I0, I0, 0.0]
p_historical = [0.25, 0.1]
prob_historical = ODEProblem(sir_ode!, u0_historical, (0.0, t_end_historical), p_historical)
sol_historical = solve(prob_historical, Tsit5())

# Plot same day on rows, forecast length on the columns
p_grid = []

betas = [0.2 + 0.01 * randn() for _ in 1:1000]
gammas = [0.1 + 0.005 * randn() for _ in 1:1000]

# Loop through each starting day
# Generate a cloud of historical trajectories
historical_trajectories = []
for i in 1:num_forecast_sims
    β = betas[i]
    γ = gammas[i]
    p = [β, γ]
    prob_hist = ODEProblem(sir_ode!, u0_historical, (0.0, t_end_historical), p)
    sol_hist = solve(prob_hist, Tsit5())
    push!(historical_trajectories, sol_hist)
end

# Define the forecast lengths and starting days
forecast_length = [5, 15, 30]
forecast_from = [20, 35, 60]

# Prepare a layout for the 3x3 plot
p_grid = []

num_forecast_sims = 500

for start_day in forecast_from
    for forecast_len in forecast_length
        # Setup forecast from the historical solution
        u0_forecast = sol_historical(start_day)
        tspan_forecast = (start_day, start_day + forecast_len)
        
        # Create a subplot for this specific combination
        p_subplot = plot(title="Day $start_day - $(start_day+forecast_len)", legend=false)
        
        # Add a vertical line to show where the forecast starts
        vline!([start_day], linestyle=:dash, color=:black, label=false)
        
        for i in 1:num_forecast_sims
            β = betas[i]
            γ = gammas[i]
            p = [β, γ]
            
            prob_forecast = ODEProblem(sir, u0_forecast, tspan_forecast, p)
            sol_forecast = solve(prob_forecast, Tsit5())

            # Plot the individual forecast trajectory on the current subplot
            plot!(p_subplot, sol_forecast, vars=(0, 2), alpha=0.1, color=:lightblue1)
        end
        
        # Add the historical curve for context
        plot!(p_subplot, sol_historical, vars=(0, 2), xlims=(0, tspan_forecast[2]), color=:gray, linewidth=2, label=false)
        push!(p_grid, p_subplot)
    end
end

plot(p_grid..., layout=(3, 3), size=(1200, 1200), xlabel="Time (days)", ylabel="Infected Population")
savefig("figs/forecast.png")</code></pre>
            </div>
            
            <h3 class="text-2xl font-semibold text-gray-900 mt-8 mb-2">Figure 5: Forecast</h3>
            <p class="text-gray-700 mb-4">
                This shows a series of forecasts starting from the days 20, 35 and 60. These days were chosen as they represent easy/hard points in the epidemic to predict. For example, the uncertainty is low from day 60 onwards, where the number of infected individuals exhibits a smooth downward trend. In contrast, the model's forecasts from day 20 show a large amount of uncertainty, correctly capturing the dynamic and unpredictable nature of the epidemic's peak.
                <br><br>
                The lengths of 5, 15 and 30 days were chosen to show that uncertainty increases as the forecasting window extends.
            </p>
            <div class="figure-container">
                <img src="https://github.com/JIC1444/JIC1444.github.io/raw/408884d0f7df79b5b0c3ff030eb8bac1dfcde532/scientific-programming-julia/figs/forecast.png" alt="A grid plot showing multiple forecast simulations.">
            </div>
        </section>
    </div>
</body>
</html>