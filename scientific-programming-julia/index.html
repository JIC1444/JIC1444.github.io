<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bayesian SIR Workflow</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // MathJax configuration to explicitly define delimiters
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .code-block {
            background-color: #f3f4f6;
            border-radius: 0.5rem;
            padding: 1rem;
            overflow-x: auto;
        }
        .figure-container {
            margin-top: 1rem;
            margin-bottom: 2rem;
        }
        .figure-container img {
            width: 100%;
            height: auto; /* Ensures images are not cropped */
            max-height: 400px; /* Optional: Sets a max height for large images */
            object-fit: contain; /* Prevents cropping and shows full image */
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        pre {
            margin: 0;
        }
        .equations {
            display: flex;
            justify-content: center;
            margin-bottom: 1rem;
        }
        .equations-inner {
            text-align: center;
        }
        /* Specific rule for the last image */
        #forecast-image {
            max-height: 800px;
        }
    </style>
</head>
<body class="bg-white text-gray-800 antialiased leading-relaxed">

    <div class="container mx-auto max-w-4xl px-4 py-8">
        <header class="text-center mb-12">
            <h1 class="text-4xl font-bold tracking-tight text-gray-900 sm:text-5xl">SIR Modelling with a Bayesian Workflow</h1>
            <p class="mt-4 text-xl text-gray-600">
                Jake Cordery - August 2025
                <br>
                <a href="https://jic1444.github.io">Back to Portfolio</a>
            </p>
        </header>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-gray-900 mb-4">0. Introduction</h2>
            <p class="text-gray-700 mb-6">
                This project extends the use of deterministic SIR ODEs by using 
                Bayesian machine learning. This is done by using Bayes' theorem 
                in order to refine a prior distribution of the possible parameter 
                values of the system of ODEs, which allows more accurate predictions 
                as well as the incorporation of uncertainty when forecasting the 
                spread of disease.
                <br><br>
                Julia is an excelllent programming language to do this in, due 
                to its high-level and intuitive syntax, which allows quick prototyping 
                - similar to Python. However, Julia also achieves performance which 
                is comparable to C - where Python falls short.
                Julia was also designed with mathematical and numerical programming 
                in mind, hence the large array of packages with optimised algorithms 
                for this style of project. The star of this project is the package 
                Turing.jl - a statistical programming language which allows 
                streamlined prototyping and ultra-performant Bayesian inference.
                <br><br>
                The structure of this project follows that of a Bayesian Workflow:
                <br>
                1. Model building
                <br>
                2. Inference
                <br>
                3. Model checking (and or improvement)
            </p>
        </section>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-gray-900 mb-4">1. Model Building & Synthetic Data Generation</h2>
            <p class="text-gray-700 mb-6">
                The first step is to define the system of ODEs which govern the 
                disease mechanics, the SIR model is perfect for simple mathematical 
                modelling of a disease. The SIR model splits a population into three 
                compartments: Susceptible ($S$), Infected ($I$) and Recovered ($R$). 
                The mathematical equations are as follows:
            </p>
            <div class="equations">
                <div class="equations-inner">
                    $$
                    \frac{dS}{dt} = -\frac{\beta SI}{N} \quad
                    \frac{dI}{dt} = \frac{\beta SI}{N} - \gamma I \quad
                    \frac{dR}{dt} = \gamma I
                    $$
                </div>
            </div>
            <p class="text-gray-700 mb-6">
                As can be seen, the rate of change in one compartment depends on the 
                infection rate $\beta$ or the recovery rate $\gamma$, and the 
                interacting populations. The Julia code below defines the system
                of equations:
            </p>
            <div class="code-block">
                <pre><code>using Turing, DifferentialEquations, Distributions

using Random
Random.seed!(42)

using StatsPlots, MCMCChains, Plots

# -----------
# Model building
# -----------
function sir(du, u, p, t)
    S, I, R = u
    β, γ = p
    N = S + I + R
    du[1] = -β * S * I / N
    du[2] = β * S * I / N - γ * I
    du[3] = γ * I
end</code></pre>
            </div>

            <p class="text-gray-700 mt-6 mb-6">
                Within this system, $\beta$ is the infection rate and $\gamma$ is the recovery rate - 
                these allow a variety of diseases to be modelled. In this case, the recovery time is set
                to be roughly 20 days, which gives $\gamma = 0.05$. $\beta = 0.25$ says that in a fully 
                susceptible population the rate at which an individual infects others is a quarter per day.
                <br><br>
                $R_0$ is the basic reproductive number, which is the expected number of cases directly 
                generated by one case in a population where all individuals are susceptible to infection. 
                $R_0$ is given by $R_0=\beta/\gamma$, hence, in this case, $R_0 = 5$, which for context gives 
                it a similar infection profile to the common cold.
                <br><br>
                Using these values, the model with known parameters is used to calculate 
                the solution to the system of ODEs. Adding noise sampled from a negative binomial
                distribution, mimics the reporting biases, miscounting and other inconsistencies which is 
                seen in real-world data.
                <br><br>
                The code below defines the initial conditions:
                <br>
                - $N$ (population) = 10,000
                <br>
                - $I_0$ (Inital number of individuals with the disease) = 150
                <br>
                - $R_0$ (Initial number of individuals who are immune to the disease) = 0
            </p>
            <div class="code-block">
                <pre><code>
# Initial conditions and constants
N = 1e4
β_true = 0.25 # per day
γ_true = 0.05 # per day (≈ 20-day infectious period)
p = [β_true, γ_true]

I0 = 150.0
S0 = N - I0
R0 = 0.0
u0 = [S0, I0, R0]

tspan = (0.0, 75.0)

# Generate the true solution
prob = ODEProblem(sir, u0, tspan, p)
sol = solve(prob, Tsit5(), saveat=1) # Save daily

# Model cumulative error in the total infected count over time
phi = 50.0
I_with_error = []
for daily_mean in sol[2, :]
    # Ensure mean is positive number for the negative binomial distribution
    if daily_mean > 0
        p_val = phi / (phi + daily_mean)
        neg_bin_dist = NegativeBinomial(phi, p_val)
        error = rand(neg_bin_dist)
        push!(I_with_error, error)
    else
        # If the deterministic mean is zero, the noisy value should also be zero
        push!(I_with_error, 0)
    end
end

plot(I_with_error,
     title="Number of Infecteds with Observation Error",
     xlabel="Days",
     ylabel="I(t)",
     linewidth=1,
     linecolor=:black,
     legend=false)
savefig("figs/observed_error_infected.png")

plot(sol, 
     label=["S(t)" "I(t)" "R(t)"], 
     title="SIR Solution with Observation Error",
     xlabel="Days",
     ylabel="Number of People",
     linewidth=2)

plot!(sol.t, 
    I_with_error,  # Plot only the noisy infected data
    label="I(t) + ε(t)", 
    markersize=3, 
    markerstrokewidth=0,
    color="black")
savefig("figs/true_sol_and_error.png")</code></pre>
            </div>

            <h3 class="text-2xl font-semibold text-gray-900 mt-8 mb-2">Figure 1: True Solution</h3>
            <p class="text-gray-700 mb-4">
                The number of infecteds, with the observation error added.
            </p>
            <div class="figure-container">
                <img src="https://github.com/JIC1444/JIC1444.github.io/raw/25200a529e121d51142062baae8108aa560fd387/scientific-programming-julia/figs/observed_error_infected.png" alt="Plot of the true SIR solution.">
            </div>

            <h3 class="text-2xl font-semibold text-gray-900 mt-8 mb-2">Figure 2: Noisy Data</h3>
            <p class="text-gray-700 mb-4">
                The solution of the SIR model with $\beta, \gamma = 0.25, 0.05$. 
                The blue trajectory is the Susceptible compartment, 
                the orange is the Infected compartment 
                and the green is the Recovered compartment.
                The infecteds with error is then plotted as a comparison.
            </p>
            <div class="figure-container">
                <img src="https://github.com/JIC1444/JIC1444.github.io/raw/25200a529e121d51142062baae8108aa560fd387/scientific-programming-julia/figs/true_sol_and_error.png" alt="Plot of the true SIR solution with noise.">
            </div>
        </section>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-gray-900 mb-4">2. Bayesian Model Definition</h2>
            <p class="text-gray-700 mb-6">
                The next step is to build the Bayesian model. This involves two key 
                components:
                <br>
                - specifying our prior beliefs (to inform the parameters)
                <br>
                - defining the likelihood that connects our model's predictions to the 
                observed data.
                <br><br>
                To begin with, imagine a dataset of recovery times for the disease, 
                this dataset shows a range of values from a few days to a month, 
                with the mode being 10 - we may be able to say from this that the r
                ecovery time is around 10 days, but with a fair bit of uncertainty. 
                Setting the weakly-informed prior as $\gamma \sim \text{Normal}(\log(0.1), 0.5)$ 
                encompasses recovery times from 1 day to 74 days.
                <br><br>
                For a disease to become an epidemic, $R_0 > 1$. Our guess of 2.0 is a 
                good starting point, and the prior on the log-transformed basic 
                reproductive number, $\log(R_0)$, is given by a Normal distribution: 
                $\log(R_0) \sim \text{Normal}(\log(2.0), 0.4)$. This prior encompasses
                 a plausible range for $R_0$ values, approximately from 0.9 to 4.4. 
                 The prior $\phi \sim \text{Gamma}(2, 5)$ is for the overdispersion 
                 parameter of the Negative Binomial likelihood, which models the amount
                  of noise in the observed data. Finally, the infection rate $\beta$ 
                  can be calculated from the relationship $\beta=R_0 \cdot \gamma$.
                <br><br>
                The code below uses Turing.jl's `@model` macro to define this. 
                `@model` enables the user to assign probability distributions 
                to variables in the function. It also takes data in as input, 
                then calculates the likelihoods, which then connects the parameters 
                to the observations. It also automatically prepares the model for 
                inference in the MCMC algorithm.
            </p>
            <div class="code-block">
                <pre><code>@model function sir_model(I, prob)
    log_γ ~ Normal(log(0.05), 0.5)
    log_R0 ~ Normal(log(2.0), 0.4)
    # Overdispersion prior (positive)
    ϕ ~ Gamma(2, 5)

    # Transform parameters 
    γ = exp(log_γ)
    R0 = exp(log_R0)
    β = R0 * γ

    # Solve ODE
    p_prob = [β, γ]
    prob = remake(prob, p=p_prob)
    predicted_sol = solve(prob, Tsit5(), saveat=1)

    # If the ODE is stiff, error is thrown as size(predicted_sol) = (3, 1)
    if predicted_sol.retcode != :Success
        Turing.@addlogprob! -Inf
        return
    end

    # Likelihood
    for i in 1:length(I)
        predicted_I = predicted_sol[2, i] 
        μ = max(predicted_I, 1e-6)
        # (r, p) parameterization
        p_likelihood = ϕ / (ϕ + μ)
        I[i] ~ NegativeBinomial(ϕ, p_likelihood) 
    end
end</code></pre>
            </div>
        </section>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-gray-900 mb-4">3. Sampling</h2>
            <p class="text-gray-700 mb-6">
                Now the Bayesian model is defined, the sampling algorithm No-U-Turn 
                Sampler (NUTS) will draw thousands of samples from the posterior 
                distribution. The posterior distribution represents the updated 
                beliefs about the parameters after observing the data.
            </p>
            <div class="code-block">
                <pre><code># -----------
# Inference
# -----------
model = sir_model(I_with_error, prob)
chain = mapreduce(c -> sample(model, NUTS(.65),1000), chainscat, 1:3)

plot(chain)
savefig("figs/chain.png")

display(summarystats(chain))</code></pre>
            </div>

            <h3 class="text-2xl font-semibold text-gray-900 mt-8 mb-2">Figure 3: Chain Plot</h3>
            <p class="text-gray-700 mb-4">
                This plot shows the trace and density of the posterior samples. 
                The trace plot has no obvious trends as it is exploring the 
                parameter space. (Note in each graph there are 3 coloured lines,
                these represent each indepedent chain of NUTS).
                The density plots show the posterior distribution for each parameter. 
                The summary of the chain shows that the mean of the posterior 
                distributions is close to the true parameter values used to 
                generate the data:
                $$ \beta \approx 0.25, \gamma \approx 0.05 $$
                With this, and the very small std, we can discern that the 
                model has converged on a suitable solution.
                This is backed up by the rhat values of ~1.00.
            </p>
            <div class="figure-container">
                <img src="https://github.com/JIC1444/JIC1444.github.io/raw/25200a529e121d51142062baae8108aa560fd387/scientific-programming-julia/figs/chain.png" alt="Plot of the MCMC chains, showing trace and density plots for the parameters.">
            </div>
            <div class="figure-container">
                <img src="https://github.com/JIC1444/JIC1444.github.io/raw/25200a529e121d51142062baae8108aa560fd387/scientific-programming-julia/figs/chain_summary.png" alt="Chain Summary.">
            </div>

        </section>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-gray-900 mb-4">4. Model Checking</h2>
            <p class="text-gray-700 mb-6">
                The next step in this workflow is to check if the fitted model 
                can reproduce data which closely resembles the observed data.
                 By taking many samples from the posterior distribution 
                 (100 in this case) these can be put into the ODE and solved 
                 to generate similar data.
            </p>
            <div class="code-block">
                <pre><code># -----------
# Posterior Checks
# -----------
log_gammas = chain[:log_γ]
log_R0s = chain[:log_R0]

# Convert posterior samples to β and γ
gammas = exp.(log_gammas)
R0s = exp.(log_R0s)
betas = gammas .* R0s

plot1 = plot(
    xlabel="Time (days)",
    ylabel="I(t)",
    title="Posterior Predictive Checks",
    legend=false,
)

# Plot a sample of 100 of the posterior solutions
for i in 1:100
    β_i = betas[i]
    γ_i = gammas[i]

    p_i = [β_i, γ_i]
    prob_i = ODEProblem(sir, u0, tspan, p_i)

    # Solve the ODE and save at the same time points
    sol_i = solve(prob_i, Tsit5(), saveat=time_points)
    plot!(plot1, sol_i.t, sol_i[2, :], color=:red, alpha=0.2)
end
plot!(plot1, I_with_error, color=:black)
savefig(plot1, "figs/generated_sols.png")</code></pre>
            </div>
            <h3 class="text-2xl font-semibold text-gray-900 mt-8 mb-2">Figure 4: Posterior-Informed Data</h3>
            <p class="text-gray-700 mb-4">
                This plot shows that the trajectories generated by
                the posteriors are a good fit, as the 'cloud' of these lines 
                encompasses much of the variance seen in the data with 
                observation errors.
            </p>
            <div class="figure-container">
                <img src="https://github.com/JIC1444/JIC1444.github.io/raw/25200a529e121d51142062baae8108aa560fd387/scientific-programming-julia/figs/generated_sols.png" alt="A plot showing a cloud of simulated trajectories.">
            </div>

        </section>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-gray-900 mb-4">Forecasting</h2>
            <p class="text-gray-700 mb-6">
                The posterior distribution can also be used to make predictions 
                about the future, from day any $n$ to $n+m$ within the epidemic. 
                By running the model forward in time with multiple sets of parameters 
                drawn from the posterior, we can quantify the uncertainty in the 
                forecasts.
            </p>
            <div class="code-block">
                <pre><code># -----------
# Posterior Check via Forecasting
# -----------
forecast_length = [5, 15, 25]
forecast_from = [10, 25, 50]

N = 1e4
β_true = 0.25 # per day
γ_true = 0.05 # per day (≈ 10-day infectious period)
p = [β_true, γ_true]

I0 = 150.0
S0 = N - I0
R0 = 0.0
u0 = [S0, I0, R0]

tspan = (0.0, 75.0)
num_simulations = 300

# Prepare a layout for the 3x3 plot
p_grid = []
for start_day in forecast_from
    for forecast_len in forecast_length
        # Setup forecast from the historical solution
        u0_forecast = sol(start_day)
        tspan_forecast = (start_day, start_day + forecast_len)
        
        # Create a subplot for this specific combination
        p_subplot = plot(
            title="Forecast from Day $start_day",
            legend=false,
            xlims=(0, start_day + forecast_len),
            xlabel="Time (days)",
            ylabel="Infected Population"
        )
        
        # Add a vertical line to show where the forecast starts
        vline!([start_day], linestyle=:dash, color=:black, label=false)
        
        # Loop through posterior samples to create the forecast
        for i in 1:num_simulations
            β = betas[i]
            γ = gammas[i]
            p_i = [β, γ]
            
            prob_forecast = ODEProblem(sir, u0_forecast, tspan_forecast, p_i)
            sol_forecast = solve(prob_forecast, Tsit5(), saveat=1)

            # Plot the individual forecast trajectory on the current subplot
            plot!(p_subplot, 
                sol_forecast, 
                vars=(0, 2), 
                alpha=0.2, 
                color=:lightblue1)
        end
        
        # Plot the true solution
        plot!(p_subplot, 
            sol, 
            vars=(0, 2), 
            tspan=(0, start_day+forecast_len), 
            linewidth=2, 
            color=:black, 
            label=false)

        push!(p_grid, p_subplot)
    end
end

plot(p_grid..., layout=(3, 3), size=(1200, 1200))
savefig("figs/forecast.png")</code></pre>
            </div>
            
            <h3 class="text-2xl font-semibold text-gray-900 mt-8 mb-2">Figure 5: Forecast</h3>
            <p class="text-gray-700 mb-4">
                This shows a series of forecasts starting from the days 10, 25 and 50. 
                These days were chosen as they represent different periods of infection rate
                in the epidemic. For example, the uncertainty is low from day 
                50 onwards, where the number of infected individuals exhibits a smooth 
                downward trend. In contrast, the model's forecasts from day 10 show a 
                large amount of uncertainty, capturing the volatile behaviour
                nature of the epidemic's peak.
                <br><br>
                The lengths of 5, 15 and 25 days were chosen to show that uncertainty 
                increases as the forecasting window extends. This usually creates a 
                'cone' of uncertainty, which can be seen best in the Day 10-35 plot.
            </p>
            <div class="figure-container">
                <img id="forecast-image" src="https://github.com/JIC1444/JIC1444.github.io/raw/25200a529e121d51142062baae8108aa560fd387/scientific-programming-julia/figs/forecast.png" alt="A grid plot showing multiple forecast simulations.">
            </div>
        </section>

        <section class="mb-12">
            <h2 class="text-3xl font-semibold text-gray-900 mb-4">Further extensions and concluding statement</h2>
            <p class="text-gray-700 mb-6">
                This model could be extended further by attempting to model a real-world
                disease. This way, the weakly-informed priors can be based off of 
                research papers and analysis. The SIR model could also incorporate more
                parameters, for example, δ for the trickling of recovereds back into
                susceptibles.
                <br><br>
                It is clear to see that when predicting phenomena modelled
                by ODEs, the Bayesian workflow provides a powerful way to find 
                a suitable distribution for the parameter values and validate the model.
                <br><br>
                The Julia language allows rapid development and prototyping of pipelines,
                along with breakneck computation. This, along with tools such as 
                DifferentialEquations.jl and Turing.jl make this language brilliant 
                choice for numerical analysis and machine learning tasks. 
            </p>
        </section>
    </div>
</body>
</html>